<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/static/styles.css" />
  <title>ANEXO I • Requisiçã</title>
</head>

<body>
  <div class="container">

    <div class="topbar">
      <div class="brand">
        <div class="brand-badge" aria-hidden="true"></div>
        <div>
          <h1>ANEXO I • Requisição (Diárias/Passagens)</h1>
          <p>Preenchimento guiado com validação e geração DOCX/PDF</p>
        </div>
      </div>
      <div class="actions">
        <a class="btn btn-ghost" href="/">Início</a>
        <span id="statusBadge" class="badge">Rascunho</span>
        <button type="button" class="btn" id="btnChatFull">Assistente (conversa)</button>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <div>
          <h2 id="stepTitle">Passo 1</h2>
          <div class="meta">
            <span id="stepMeta">Preencha os dados para avançar.</span>
          </div>
        </div>
        <span class="pill">
          <span id="stepCount">1</span>/<span id="stepTotal">9</span>
        </span>
      </div>

      <div style="margin-top:10px;">
        <div
          style="height:10px;border-radius:999px;border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.04);overflow:hidden;">
          <div id="progressBar"
            style="height:100%;width:0%;background:linear-gradient(135deg, rgba(79,140,255,0.95), rgba(119,167,255,0.62));">
          </div>
        </div>
      </div>

      <div id="errors" class="errors" style="display:none;"></div>
    </div>

    <form id="wizardForm" novalidate>

      <!-- STEP 1: Tipo + Data -->
      <section class="card step" data-step="1" data-title="Tipo de solicitação"
        data-subtitle="Define o prazo automaticamente (10 dias sem passagens; 30 dias com passagens).">
        <h2>1) Tipo de solicitação</h2>

        <label>Tipo</label>
        <select name="tipo_solicitacao" required>
          <option value="">Selecione...</option>
          <option value="diarias">Diárias</option>
          <option value="passagens">Passagens</option>
          <option value="diarias_e_passagens">Diárias + Passagens</option>
        </select>

        <label>Data da solicitação</label>
        <input name="data_solicitacao" type="date" required>

        <div class="helper">
          O sistema calculará automaticamente “fora do prazo” com base na data da ida.
        </div>
      </section>

      <!-- STEP 2: Identificação -->
      <section class="card step" data-step="2" data-title="Identificação do servidor"
        data-subtitle="Dados pessoais e bancários.">
        <h2>2) Identificação do servidor</h2>
        <div class="grid2">
          <div>
            <label>Nome completo</label>
            <input name="servidor.nome_completo" required>
          </div>
          <div>
            <label>Cargo/Função</label>
            <input name="servidor.cargo_funcao" required>
          </div>
          <div>
            <label>CPF (somente números)</label>
            <input name="servidor.cpf" inputmode="numeric" pattern="[0-9]{11}" maxlength="11" required
              placeholder="Ex.: 12345678901">
          </div>
          <div>
            <label>RG</label>
            <input name="servidor.rg" required>
          </div>
          <div>
            <label>Data de nascimento</label>
            <input name="servidor.data_nascimento" type="date" required>
          </div>
          <div>
            <label>SIAPE (somente números)</label>
            <input name="servidor.siape" inputmode="numeric" pattern="[0-9]{4,15}" required>
          </div>
          <div>
            <label>Nome da mãe</label>
            <input name="servidor.nome_mae" required>
          </div>
          <div>
            <label>Telefone (somente números)</label>
            <input name="servidor.telefone" inputmode="numeric" pattern="[0-9]{10,11}" required
              placeholder="DDD+Número">
          </div>
          <div style="grid-column:1/-1;">
            <label>Endereço</label>
            <input name="servidor.endereco" required>
          </div>
          <div style="grid-column:1/-1;">
            <label>E-mail</label>
            <input name="servidor.email" type="email" required>
          </div>
          <div>
            <label>Banco</label>
            <input name="servidor.dados_bancarios.banco" required placeholder="Ex.: 001">
          </div>
          <div>
            <label>Agência</label>
            <input name="servidor.dados_bancarios.agencia" inputmode="numeric" pattern="[0-9]{1,10}" required>
          </div>
          <div>
            <label>Conta</label>
            <input name="servidor.dados_bancarios.conta" inputmode="numeric" pattern="[0-9]{1,20}" required>
          </div>
        </div>
      </section>

      <!-- STEP 3: Motivo -->
      <section class="card step" data-step="3" data-title="Motivo da viagem"
        data-subtitle="Descreva de forma objetiva o motivo da solicitação.">
        <h2>3) Motivo da viagem</h2>
        <label>Descrição do motivo</label>
        <textarea name="motivo_viagem" minlength="20" required
          placeholder="Descreva o motivo da viagem (mínimo 20 caracteres)."></textarea>
      </section>

      <!-- STEP 4: Ida -->
      <section class="card step" data-step="4" data-title="Trecho de ida"
        data-subtitle="Origem, destino e data/hora da partida.">
        <h2>4) Ida</h2>
        <div class="grid2">
          <div>
            <label>Origem</label>
            <input name="trechos.ida.origem" required>
          </div>
          <div>
            <label>Destino</label>
            <input name="trechos.ida.destino" required>
          </div>
          <div style="grid-column:1/-1;">
            <label>Data e hora da ida</label>
            <input name="trechos.ida.data_hora" type="datetime-local" required>
          </div>
        </div>
      </section>

      <!-- STEP 5: Retorno -->
      <section class="card step" data-step="5" data-title="Trecho de retorno"
        data-subtitle="Origem, destino e data/hora do retorno.">
        <h2>5) Retorno</h2>
        <div class="grid2">
          <div>
            <label>Origem</label>
            <input name="trechos.retorno.origem" required>
          </div>
          <div>
            <label>Destino</label>
            <input name="trechos.retorno.destino" required>
          </div>
          <div style="grid-column:1/-1;">
            <label>Data e hora do retorno</label>
            <input name="trechos.retorno.data_hora" type="datetime-local" required>
          </div>
        </div>
        <div class="helper">Regra: retorno não pode ser anterior à ida.</div>
      </section>

      <!-- STEP 6: Missão -->
      <section class="card step" data-step="6" data-title="Período da missão"
        data-subtitle="Início e término dentro dos trechos.">
        <h2>6) Período da missão</h2>
        <div class="grid2">
          <div>
            <label>Início da missão</label>
            <input name="missao.inicio_data_hora" type="datetime-local" required>
          </div>
          <div>
            <label>Término da missão</label>
            <input name="missao.termino_data_hora" type="datetime-local" required>
          </div>
        </div>
        <div class="helper">
          Regras: término ≥ início; início ≥ ida; término ≤ retorno.
        </div>
      </section>

      <!-- STEP 7: Recurso + Transporte -->
      <section class="card step" data-step="7" data-title="Recurso e transporte"
        data-subtitle="Selecione débito do recurso e meio(s) de transporte.">
        <h2>7) Recurso e transporte</h2>

        <label>Débito do recurso</label>
        <select name="debito_recurso.tipo" id="deb_tipo" required>
          <option value="">Selecione...</option>
          <option value="cchsa">CCHSA</option>
          <option value="cavn">CAVN</option>
          <option value="projeto">Projeto</option>
          <option value="outros">Outros</option>
        </select>

        <div id="debDetalheWrap" style="display:none;">
          <label>Detalhe (obrigatório para Projeto/Outros)</label>
          <input name="debito_recurso.detalhe" id="deb_det"
            placeholder="Ex.: Nome/código do projeto ou detalhe de outros">
        </div>

        <hr class="sep" />

        <label>Meio(s) de transporte</label>

        <label class="checkbox">
          <input type="checkbox" name="transporte.meios" value="veiculo_oficial">
          <div><span>Veículo oficial</span><small>Quando houver disponibilidade institucional.</small></div>
        </label>

        <label class="checkbox">
          <input type="checkbox" name="transporte.meios" value="empresa_terrestre">
          <div><span>Empresa terrestre</span><small>Ônibus/van/serviço terrestre.</small></div>
        </label>

        <label class="checkbox">
          <input type="checkbox" name="transporte.meios" value="empresa_aerea">
          <div><span>Empresa aérea</span><small>Quando houver emissão de passagens aéreas.</small></div>
        </label>

        <label class="checkbox">
          <input type="checkbox" name="transporte.meios" value="veiculo_proprio" id="chkVeicProprio">
          <div><span>Veículo próprio</span><small>Exige ciência do termo de opção.</small></div>
        </label>

        <div id="termoWrap" style="display:none;margin-top:10px;">
          <label class="checkbox">
            <input type="checkbox" name="transporte.termo_veiculo_proprio_ciente" value="true" id="termoCiente">
            <div><span>Ciente do termo de opção</span><small>Obrigatório quando marcar “veículo próprio”.</small></div>
          </label>
        </div>
      </section>

      <!-- STEP 8: Checagem automática + justificativas -->
      <section class="card step" data-step="8" data-title="Checagem e justificativas"
        data-subtitle="O sistema exige justificativas quando necessário.">
        <h2>8) Checagem e justificativas</h2>

        <div class="row">
          <span id="badgePrazo" class="badge">Prazo: —</span>
          <span id="badgeFds" class="badge">Fim de semana: —</span>
        </div>

        <div class="helper">
          Observação: “Fora do prazo” é calculado automaticamente conforme o tipo (10/30 dias) e a data da ida.
        </div>

        <hr class="sep" />

        <label class="checkbox">
          <input type="checkbox" name="flags.envolve_fds_feriado_ou_dia_anterior" value="true" id="flagFds">
          <div>
            <span>Exigir justificativa (fim de semana/feriado/saída dia anterior)</span>
            <small>O sistema marca automaticamente se a ida cair em sábado/domingo; você pode marcar manualmente para
              “dia anterior”.</small>
          </div>
        </label>

        <div id="wrapJustFds" style="display:none;">
          <label>Justificativa (fim de semana/feriado/dia anterior)</label>
          <textarea name="justificativas.justificativa_fds_feriado_dia_anterior" id="justFds"
            placeholder="Informe a justificativa."></textarea>
        </div>

        <label class="checkbox" style="margin-top:10px;">
          <input type="checkbox" name="flags.fora_do_prazo" value="true" id="flagPrazo" disabled>
          <div>
            <span>Solicitação fora do prazo (calculado automaticamente)</span>
            <small>Se estiver fora do prazo, a justificativa será obrigatória.</small>
          </div>
        </label>

        <div id="wrapJustPrazo" style="display:none;">
          <label>Justificativa (fora do prazo)</label>
          <textarea name="justificativas.justificativa_fora_prazo" id="justPrazo"
            placeholder="Informe a justificativa fora do prazo."></textarea>
        </div>
      </section>

      <!-- STEP 9: Revisão + geração -->
      <section class="card step" data-step="9" data-title="Revisão final"
        data-subtitle="Revise o resumo e gere o documento.">
        <h2>9) Revisão final</h2>

        <div class="card" style="margin:0;">
          <div class="card-header">
            <div>
              <h2>Resumo</h2>
              <div class="meta">Confira antes de gerar.</div>
            </div>
            <span id="reviewBadge" class="badge">—</span>
          </div>

          <pre id="reviewText"
            style="white-space:pre-wrap;margin:0;color:rgba(255,255,255,0.85);font-size:12.5px;"></pre>
        </div>

        <hr class="sep" />

        <div class="row">
          <button type="button" class="btn btn-primary" id="btnDocx">Gerar DOCX</button>
          <button type="button" class="btn" id="btnPdf">Gerar PDF</button>
        </div>

        <div class="helper">
          Se houver erro de validação, o sistema mostrará o motivo e direcionará para correção.
        </div>
      </section>

      <!-- Navigation -->
      <div class="card">
        <div class="row">
          <button type="button" class="btn btn-ghost" id="btnBack">Voltar</button>
          <button type="button" class="btn btn-primary" id="btnNext">Avançar</button>
        </div>
      </div>

    </form>
  </div>

  <div id="chatFullModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:10000;">
    <div class="card" style="max-width:980px; margin:4vh auto; padding:0; overflow:hidden;">
      <div class="card-header" style="padding:14px 16px;">
        <div>
          <h2>Assistente de Requisição (ANEXO I)</h2>
          <div class="meta" id="chatFullMeta">Vou coletar as informações e evitar erros automaticamente.</div>
        </div>
        <button type="button" class="btn btn-ghost" id="chatFullClose">Fechar</button>
      </div>

      <div id="chatFullTimeline"
        style="height:62vh; overflow:auto; padding:14px 16px; background:rgba(255,255,255,0.02);"></div>

      <div style="padding:12px 16px; border-top:1px solid rgba(255,255,255,0.08);">
        <div id="chatFullQuick" class="row" style="flex-wrap:wrap; gap:8px;"></div>

        <div id="chatFullTextRow" class="row" style="margin-top:10px; display:none;">
          <input id="chatFullText" type="text" placeholder="Digite aqui..." style="flex:1;">
          <button type="button" class="btn btn-primary" id="chatFullSend">Enviar</button>
        </div>

        <div id="chatFullDateRow" class="row" style="margin-top:10px; display:none;">
          <input id="chatFullDate" type="date">
          <button type="button" class="btn btn-primary" id="chatFullDateOk">OK</button>
        </div>

        <div id="chatFullDTrow" class="row" style="margin-top:10px; display:none;">
          <input id="chatFullDT" type="datetime-local">
          <button type="button" class="btn btn-primary" id="chatFullDTok">OK</button>
        </div>

        <div class="helper" style="margin-top:8px;">
          Observação: os dados ficam no seu navegador e só vão para o servidor ao gerar o documento.
        </div>
      </div>
    </div>
  </div>


  <div id="downloadModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:10001;">
    <div class="card" style="max-width:720px; margin:10vh auto; padding:16px;">
      <div class="card-header">
        <div>
          <h2>Documento pronto para gerar</h2>
          <div class="meta">Escolha o formato para baixar. Você ainda poderá revisar antes, se quiser.</div>
        </div>
        <button type="button" class="btn btn-ghost" id="downloadClose">Fechar</button>
      </div>

      <div id="downloadInfo" class="card" style="margin:0; padding:12px;">
        <div class="helper" id="downloadSummary">Resumo...</div>
      </div>

      <hr class="sep" />

      <div class="row" style="justify-content:flex-end;">
        <button type="button" class="btn" id="btnReviewForm">Revisar no formulário</button>
        <button type="button" class="btn btn-primary" id="btnDownloadDOCX">Baixar DOCX</button>
        <button type="button" class="btn btn-primary" id="btnDownloadPDF">Baixar PDF</button>
      </div>
    </div>
  </div>


  <script>


    function applyPayloadToFormByName(payload) {
      if (!payload || typeof payload !== "object") return;

      const setField = (name, value) => {
        const el = document.querySelector(`[name="${name}"]`);
        if (!el) return;

        // datetime-local: usa "YYYY-MM-DDTHH:MM"
        if (el.type === "datetime-local" && typeof value === "string") {
          el.value = value.slice(0, 16);
          return;
        }

        // checkbox
        if (el.type === "checkbox") {
          el.checked = !!value;
          return;
        }

        // select/text/date/etc.
        el.value = (value ?? "");
      };

      const walk = (obj, prefix = "") => {
        Object.entries(obj).forEach(([k, v]) => {
          const path = prefix ? `${prefix}.${k}` : k;

          if (v === null || v === undefined) return;

          // Arrays: caso especial transporte.meios
          if (Array.isArray(v)) {
            if (path === "transporte.meios") {
              // Estratégia 1: se o HTML tiver um select múltiplo com name="transporte.meios"
              const el = document.querySelector(`[name="${path}"]`);
              if (el && el.tagName === "SELECT" && el.multiple) {
                [...el.options].forEach(opt => opt.selected = v.includes(opt.value));
              } else {
                // Estratégia 2: checkboxes com names tipo transporte.meios.veiculo_oficial = true
                // (se você não usa isso, ignore)
                v.forEach(item => setField(`transporte.meios.${item}`, true));
              }
              return;
            }

            // Caso genérico: se houver campo com name igual ao path, tenta setar como string
            setField(path, v.join(","));
            return;
          }

          // Objeto: continua
          if (typeof v === "object") {
            walk(v, path);
            return;
          }

          // Primitivo
          setField(path, v);
        });
      };

      walk(payload);

      // Ajustes comuns (se existir no seu HTML)
      const debTipo = document.querySelector(`[name="debito_recurso.tipo"]`);
      if (debTipo) debTipo.dispatchEvent(new Event("change"));

      const meios = payload?.transporte?.meios || [];
      const termo = payload?.transporte?.termo_veiculo_proprio_ciente;

      // Se você tem checkboxes específicos (opcional):
      const chkVP = document.getElementById("chkVeicProprio");
      if (chkVP) {
        chkVP.checked = meios.includes("veiculo_proprio");
        chkVP.dispatchEvent(new Event("change"));
      }
      const termoEl = document.getElementById("termoCiente");
      if (termoEl && typeof termo === "boolean") {
        termoEl.checked = termo;
      }
    }


    /* ---------------- Wizard core ---------------- */
    const form = document.getElementById("wizardForm");
    const steps = Array.from(document.querySelectorAll(".step"));
    const total = steps.length;
    document.getElementById("stepTotal").textContent = total;

    let current = 1;

    const elTitle = document.getElementById("stepTitle");
    const elMeta = document.getElementById("stepMeta");
    const elCount = document.getElementById("stepCount");
    const elBar = document.getElementById("progressBar");
    const elErrors = document.getElementById("errors");
    const statusBadge = document.getElementById("statusBadge");

    function showErrors(msgs) {
      if (!msgs || !msgs.length) {
        elErrors.style.display = "none";
        elErrors.textContent = "";
        return;
      }
      elErrors.style.display = "block";
      elErrors.textContent = msgs.map(m => `• ${m}`).join("\n");
    }

    function setStatus(text, kind) {
      statusBadge.textContent = text;
      statusBadge.className = "badge " + (kind || "");
    }

    function gotoStep(n) {
      current = Math.max(1, Math.min(total, n));
      steps.forEach(s => s.style.display = (Number(s.dataset.step) === current) ? "block" : "none");

      const active = steps[current - 1];
      elTitle.textContent = `Passo ${current} • ${active.dataset.title || ""}`;
      elMeta.textContent = active.dataset.subtitle || "";
      elCount.textContent = current;

      elBar.style.width = `${Math.round((current - 1) / (total - 1) * 100)}%`;

      document.getElementById("btnBack").disabled = current === 1;
      document.getElementById("btnNext").textContent = (current === total) ? "Finalizar" : "Avançar";

      showErrors(null);

      // hooks per step
      if (current === 8) refreshAutoFlags();
      if (current === 9) renderReview();
    }

    function getSection(stepNumber) {
      return steps.find(s => Number(s.dataset.step) === stepNumber);
    }

    function validateStep(stepNumber) {
      const section = getSection(stepNumber);
      const inputs = Array.from(section.querySelectorAll("input, select, textarea"));

      // HTML validity
      let ok = true;
      const msgs = [];

      // custom rules
      function dtValue(name) {
        const el = form.querySelector(`[name="${name}"]`);
        if (!el || !el.value) return null;
        return new Date(el.value);
      }

      // basic required validation with custom messages
      for (const el of inputs) {
        // ignore disabled
        if (el.disabled) continue;

        // conditional fields: hide => skip
        const wrap = el.closest("[style*='display:none']");
        if (wrap) continue;

        if (el.hasAttribute("required") && !el.value) {
          ok = false;
          msgs.push("Preencha este campo para continuar.");
          el.focus();
          break;
        }
        if (el.tagName === "INPUT" && el.getAttribute("pattern")) {
          const re = new RegExp("^" + el.getAttribute("pattern") + "$");
          if (el.value && !re.test(el.value)) {
            ok = false;
            msgs.push("Informe um valor válido.");
            el.focus();
            break;
          }
        }
        if (el.tagName === "TEXTAREA" && el.getAttribute("minlength")) {
          const min = Number(el.getAttribute("minlength"));
          if (el.value && el.value.length < min) {
            ok = false;
            msgs.push(`Informe pelo menos ${min} caracteres.`);
            el.focus();
            break;
          }
        }
      }

      // step-specific cross-field validations (before leaving)
      if (ok && stepNumber === 5) {
        const ida = dtValue("trechos.ida.data_hora");
        const ret = dtValue("trechos.retorno.data_hora");
        if (ida && ret && ret < ida) {
          ok = false;
          msgs.push("A data/hora de retorno não pode ser anterior à ida.");
        }
      }

      if (ok && stepNumber === 6) {
        const ida = dtValue("trechos.ida.data_hora");
        const ret = dtValue("trechos.retorno.data_hora");
        const mi = dtValue("missao.inicio_data_hora");
        const mt = dtValue("missao.termino_data_hora");

        if (mi && mt && mt < mi) {
          ok = false;
          msgs.push("O término da missão não pode ser anterior ao início.");
        } else if (ida && mi && mi < ida) {
          ok = false;
          msgs.push("O início da missão não pode ser anterior à partida.");
        } else if (ret && mt && mt > ret) {
          ok = false;
          msgs.push("O término da missão não pode ser posterior ao retorno.");
        }
      }

      if (ok && stepNumber === 7) {
        const meios = Array.from(form.querySelectorAll('input[name="transporte.meios"]:checked')).map(x => x.value);
        if (meios.length === 0) {
          ok = false;
          msgs.push("Selecione ao menos um meio de transporte para continuar.");
        }
        if (ok && meios.includes("veiculo_proprio")) {
          const termo = form.querySelector("#termoCiente");
          if (!termo.checked) {
            ok = false;
            msgs.push("Marque “Ciente do termo” para veículo próprio.");
          }
        }

        const debTipo = form.querySelector("#deb_tipo").value;
        const debDet = (form.querySelector("#deb_det").value || "").trim();
        if (ok && (debTipo === "projeto" || debTipo === "outros") && debDet.length < 2) {
          ok = false;
          msgs.push("Informe o detalhe do recurso (Projeto/Outros).");
        }
      }

      if (ok && stepNumber === 8) {
        // If flags require justification, enforce non-empty
        const flagFds = document.getElementById("flagFds").checked;
        const fdsText = (document.getElementById("justFds").value || "").trim();
        if (flagFds && fdsText.length < 10) {
          ok = false;
          msgs.push("Informe a justificativa para fim de semana/feriado ou saída no dia anterior.");
        }
        const flagPrazo = document.getElementById("flagPrazo").checked; // disabled but set by system
        const prazoText = (document.getElementById("justPrazo").value || "").trim();
        if (flagPrazo && prazoText.length < 10) {
          ok = false;
          msgs.push("Solicitação fora do prazo. Informe a justificativa.");
        }
      }

      showErrors(ok ? null : msgs);
      return ok;
    }

    /* =========================
   Assistente Conversacional COMPLETO (ANEXO I) — sem IA externa
   ========================= */

    const chatFull = {
      state: "start",
      data: {
        tipo_solicitacao: null,
        data_solicitacao: null,

        servidor: {
          nome_completo: null,
          cargo_funcao: null,
          cpf: null,
          rg: null,
          data_nascimento: null,
          siape: null,
          nome_mae: null,
          endereco: null,
          telefone: null,
          email: null,
          dados_bancarios: { banco: null, agencia: null, conta: null }
        },

        motivo_viagem: null,

        trechos: {
          ida: { origem: null, destino: null, data_hora: null },
          retorno: { origem: null, destino: null, data_hora: null }
        },

        missao: { inicio_data_hora: null, termino_data_hora: null },

        debito_recurso: { tipo: null, detalhe: null },

        transporte: { meios: [], termo_veiculo_proprio_ciente: null },

        flags: {
          envolve_fds_feriado_ou_dia_anterior: false,
          fora_do_prazo: false
        },

        justificativas: {
          justificativa_fds_feriado_dia_anterior: null,
          justificativa_fora_prazo: null
        },

        // controles internos do chat
        _manual_feriado_dia_anterior: false
      }
    };

    const m = {
      modal: document.getElementById("chatFullModal"),
      tl: document.getElementById("chatFullTimeline"),
      quick: document.getElementById("chatFullQuick"),
      meta: document.getElementById("chatFullMeta"),

      textRow: document.getElementById("chatFullTextRow"),
      text: document.getElementById("chatFullText"),
      send: document.getElementById("chatFullSend"),

      dateRow: document.getElementById("chatFullDateRow"),
      date: document.getElementById("chatFullDate"),
      dateOk: document.getElementById("chatFullDateOk"),

      dtRow: document.getElementById("chatFullDTrow"),
      dt: document.getElementById("chatFullDT"),
      dtOk: document.getElementById("chatFullDTok"),

      close: document.getElementById("chatFullClose"),
      open: document.getElementById("btnChatFull")
    };

    function scrollTL() { m.tl.scrollTop = m.tl.scrollHeight; }

    function addBubble(role, text) {
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.margin = "10px 0";
      wrap.style.justifyContent = role === "bot" ? "flex-start" : "flex-end";

      const bubble = document.createElement("div");
      bubble.style.maxWidth = "78%";
      bubble.style.padding = "10px 12px";
      bubble.style.borderRadius = "12px";
      bubble.style.whiteSpace = "pre-wrap";
      bubble.style.lineHeight = "1.35";
      bubble.style.border = "1px solid rgba(255,255,255,0.10)";
      bubble.style.background = role === "bot" ? "rgba(255,255,255,0.06)" : "rgba(56,189,248,0.12)";
      bubble.style.borderColor = role === "bot" ? "rgba(255,255,255,0.10)" : "rgba(56,189,248,0.25)";
      bubble.textContent = text;

      wrap.appendChild(bubble);
      m.tl.appendChild(wrap);
      scrollTL();
    }

    function setMode(mode) {
      m.quick.style.display = mode === "quick" ? "flex" : "none";
      m.textRow.style.display = mode === "text" ? "flex" : "none";
      m.dateRow.style.display = mode === "date" ? "flex" : "none";
      m.dtRow.style.display = mode === "datetime" ? "flex" : "none";
    }

    function setQuick(buttons) {
      m.quick.innerHTML = "";
      buttons.forEach(b => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = b.primary ? "btn btn-primary" : "btn";
        btn.textContent = b.label;
        btn.addEventListener("click", b.onClick);
        m.quick.appendChild(btn);
      });
    }

    function onlyDigits(s) { return (s || "").replace(/\D+/g, ""); }
    function isEmail(s) { return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s || ""); }
    function isPhoneDigits(s) { return /^[0-9]{10,11}$/.test(s || ""); }
    function isSiape(s) { return /^[0-9]{4,15}$/.test(s || ""); }
    function isRG(s) { return (s || "").trim().length >= 3 && (s || "").trim().length <= 20; }
    function isMinMax(s, min, max) { const t = (s || "").trim(); return t.length >= min && t.length <= max; }
    function isNumLen(s, min, max) { return new RegExp(`^[0-9]{${min},${max}}$`).test(s || ""); }

    // CPF (validação DV)
    function isCPF(cpf) {
      cpf = onlyDigits(cpf);
      if (!/^[0-9]{11}$/.test(cpf)) return false;
      if (/^(\d)\1{10}$/.test(cpf)) return false;

      let sum = 0;
      for (let i = 0; i < 9; i++) sum += parseInt(cpf[i]) * (10 - i);
      let d1 = (sum * 10) % 11;
      if (d1 === 10) d1 = 0;
      if (d1 !== parseInt(cpf[9])) return false;

      sum = 0;
      for (let i = 0; i < 10; i++) sum += parseInt(cpf[i]) * (11 - i);
      let d2 = (sum * 10) % 11;
      if (d2 === 10) d2 = 0;
      return d2 === parseInt(cpf[10]);
    }

    function isWeekend(dateStr) { // dateStr yyyy-mm-dd
      const dt = new Date(dateStr + "T00:00:00");
      const d = dt.getDay();
      return d === 0 || d === 6;
    }

    function daysDiff(dateA, dateB) { // yyyy-mm-dd
      const a = new Date(dateA + "T00:00:00");
      const b = new Date(dateB + "T00:00:00");
      return Math.round((b - a) / (1000 * 60 * 60 * 24));
    }

    function computeFlags() {
      const d = chatFull.data;
      const idaDT = d.trechos.ida.data_hora; // datetime-local
      const sol = d.data_solicitacao;

      // envolve_fds: pelo menos fim de semana OU manual marcado
      let envolve = d._manual_feriado_dia_anterior;

      if (idaDT) {
        const idaDate = idaDT.split("T")[0];
        if (isWeekend(idaDate)) envolve = true;
      }
      d.flags.envolve_fds_feriado_ou_dia_anterior = envolve;

      // fora do prazo: compara data_solicitacao com data da ida
      if (sol && idaDT) {
        const idaDate = idaDT.split("T")[0];
        const delta = daysDiff(sol, idaDate); // ida - solic
        const limite = (d.tipo_solicitacao === "diarias") ? 10 : 30;
        d.flags.fora_do_prazo = delta < limite; // ida muito próxima => fora do prazo
      } else {
        d.flags.fora_do_prazo = false;
      }
    }

    function validateTimeline() {
      const d = chatFull.data;
      const ida = d.trechos.ida.data_hora ? new Date(d.trechos.ida.data_hora) : null;
      const ret = d.trechos.retorno.data_hora ? new Date(d.trechos.retorno.data_hora) : null;
      const mi = d.missao.inicio_data_hora ? new Date(d.missao.inicio_data_hora) : null;
      const mf = d.missao.termino_data_hora ? new Date(d.missao.termino_data_hora) : null;

      const errs = [];
      if (ida && ret && ret < ida) errs.push("O retorno não pode ser antes da ida.");
      if (mi && mf && mf < mi) errs.push("O término da missão não pode ser antes do início.");
      if (ida && mi && mi < ida) errs.push("O início da missão não pode ser antes da ida.");
      if (ret && mf && mf > ret) errs.push("O término da missão não pode ser depois do retorno.");
      return errs;
    }

    function ask() {
      const s = chatFull.state;
      const d = chatFull.data;

      // Helpers de pergunta
      const askText = (msg, meta = "") => { addBubble("bot", msg); if (meta) m.meta.textContent = meta; setMode("text"); };
      const askDate = (msg) => { addBubble("bot", msg); setMode("date"); };
      const askDT = (msg) => { addBubble("bot", msg); setMode("datetime"); };
      const askQuick = (msg, buttons) => { addBubble("bot", msg); setMode("quick"); setQuick(buttons); };

      if (s === "start") {
        askQuick(
          "Olá. Vou te ajudar a preencher a requisição completa, incluindo dados do servidor, e vou corrigir inconsistências automaticamente.\nVamos começar: qual é o tipo de solicitação?",
          [
            { label: "Diárias", primary: true, onClick: () => reply("tipo_solicitacao", "diarias") },
            { label: "Passagens", onClick: () => reply("tipo_solicitacao", "passagens") },
            { label: "Diárias + Passagens", onClick: () => reply("tipo_solicitacao", "diarias_e_passagens") },
          ]
        );
        return;
      }

      if (s === "data_solicitacao") { askDate("Qual a data da solicitação (preenchimento)?"); return; }

      // Servidor (dados pessoais)
      if (s === "servidor.nome_completo") { askText("Seu nome completo (sem abreviações)."); return; }
      if (s === "servidor.cargo_funcao") { askText("Seu cargo/função."); return; }
      if (s === "servidor.cpf") { askText("Seu CPF (somente números)."); return; }
      if (s === "servidor.rg") { askText("Seu RG (como consta no documento)."); return; }
      if (s === "servidor.data_nascimento") { askDate("Sua data de nascimento."); return; }
      if (s === "servidor.siape") { askText("Sua matrícula SIAPE (somente números)."); return; }
      if (s === "servidor.nome_mae") { askText("Nome completo da mãe (como consta no documento)."); return; }
      if (s === "servidor.endereco") { askText("Endereço completo (logradouro, nº, bairro, cidade/UF)."); return; }
      if (s === "servidor.telefone") { askText("Telefone com DDD (somente números)."); return; }
      if (s === "servidor.email") { askText("E-mail institucional."); return; }
      if (s === "servidor.banco") { askText("Banco (ex.: Banco do Brasil, Caixa)."); return; }
      if (s === "servidor.agencia") { askText("Agência (somente números)."); return; }
      if (s === "servidor.conta") { askText("Conta (somente números)."); return; }

      // Viagem e missão
      if (s === "trechos.ida.origem") { askText("Origem da ida (cidade/UF)."); return; }
      if (s === "trechos.ida.destino") { askText("Destino da ida (cidade/UF)."); return; }
      if (s === "trechos.ida.data_hora") { askDT("Data e hora da ida."); return; }

      if (s === "trechos.retorno.origem") {
        askQuick(
          "Origem do retorno. Normalmente é o destino da ida. Confirmar?",
          [
            {
              label: `Usar “${d.trechos.ida.destino || "destino da ida"}”`, primary: true, onClick: () => {
                if (d.trechos.ida.destino) { reply("trechos.retorno.origem", d.trechos.ida.destino); }
                else { chatFull.state = "trechos.retorno.origem_text"; ask(); }
              }
            },
            { label: "Informar manualmente", onClick: () => { chatFull.state = "trechos.retorno.origem_text"; ask(); } },
          ]
        );
        return;
      }
      if (s === "trechos.retorno.origem_text") { askText("Digite a origem do retorno (cidade/UF)."); return; }

      if (s === "trechos.retorno.destino") {
        askQuick(
          "Destino do retorno. Normalmente é a origem da ida. Confirmar?",
          [
            {
              label: `Usar “${d.trechos.ida.origem || "origem da ida"}”`, primary: true, onClick: () => {
                if (d.trechos.ida.origem) { reply("trechos.retorno.destino", d.trechos.ida.origem); }
                else { chatFull.state = "trechos.retorno.destino_text"; ask(); }
              }
            },
            { label: "Informar manualmente", onClick: () => { chatFull.state = "trechos.retorno.destino_text"; ask(); } },
          ]
        );
        return;
      }
      if (s === "trechos.retorno.destino_text") { askText("Digite o destino do retorno (cidade/UF)."); return; }

      if (s === "trechos.retorno.data_hora") { askDT("Data e hora do retorno."); return; }

      if (s === "missao.inicio_data_hora") { askDT("Início da missão (data e hora)."); return; }
      if (s === "missao.termino_data_hora") { askDT("Término da missão (data e hora)."); return; }

      // Motivo (texto — aqui pode ser menu opcional + texto final)
      if (s === "motivo_viagem") {
        askQuick(
          "Agora o motivo da viagem. Quer que eu monte um texto objetivo a partir de um modelo?",
          [
            { label: "Sim (modelo)", primary: true, onClick: () => { chatFull.state = "motivo.modelo"; ask(); } },
            { label: "Não, vou escrever", onClick: () => { chatFull.state = "motivo.texto_livre"; ask(); } },
          ]
        );
        return;
      }
      if (s === "motivo.modelo") {
        askQuick(
          "Qual o tipo principal?",
          [
            { label: "Evento (congresso/seminário)", primary: true, onClick: () => reply("motivo.modelo", "evento") },
            { label: "Capacitação/Curso", onClick: () => reply("motivo.modelo", "capacitacao") },
            { label: "Reunião técnica", onClick: () => reply("motivo.modelo", "reuniao") },
            { label: "Visita técnica", onClick: () => reply("motivo.modelo", "visita") },
          ]
        );
        return;
      }
      if (s === "motivo.objetivo_curto") { askText("Em uma frase: objetivo principal (ex.: apresentar trabalho / capacitação / alinhamento técnico)."); return; }
      if (s === "motivo.texto_livre") { askText("Escreva o motivo da viagem (mín. 20 caracteres)."); return; }

      // Débito
      if (s === "debito_recurso.tipo") {
        askQuick(
          "De onde saem os recursos (débito)?",
          [
            { label: "CCHSA", primary: true, onClick: () => reply("debito_recurso.tipo", "cchsa") },
            { label: "CAVN", onClick: () => reply("debito_recurso.tipo", "cavn") },
            { label: "Projeto", onClick: () => reply("debito_recurso.tipo", "projeto") },
            { label: "Outros", onClick: () => reply("debito_recurso.tipo", "outros") },
          ]
        );
        return;
      }
      if (s === "debito_recurso.detalhe") { askText("Informe o detalhe (obrigatório para Projeto/Outros)."); return; }

      // Transporte (multi-seleção em conversa)
      if (s === "transporte.meios") {
        const mk = (label, value) => ({
          label: (d.transporte.meios.includes(value) ? "✓ " : "") + label,
          onClick: () => {
            const arr = d.transporte.meios;
            if (arr.includes(value)) d.transporte.meios = arr.filter(x => x !== value);
            else d.transporte.meios = [...arr, value];
            ask(); // re-render
          }
        });

        askQuick(
          "Transporte: você pode marcar mais de uma opção. Quando terminar, clique em “Continuar”.",
          [
            mk("Veículo oficial", "veiculo_oficial"),
            mk("Empresa terrestre", "empresa_terrestre"),
            mk("Empresa aérea", "empresa_aerea"),
            mk("Veículo próprio", "veiculo_proprio"),
            {
              label: "Continuar",
              primary: true,
              onClick: () => {
                if (!d.transporte.meios.length) {
                  addBubble("bot", "Preciso que você selecione pelo menos um meio de transporte.");
                  return;
                }
                if (d.transporte.meios.includes("veiculo_proprio")) {
                  chatFull.state = "transporte.termo";
                  ask();
                } else {
                  chatFull.state = "flags.check";
                  ask();
                }
              }
            }
          ]
        );
        return;
      }

      if (s === "transporte.termo") {
        askQuick(
          "Você confirma ciência do termo de opção para veículo próprio?",
          [
            { label: "Sim, estou ciente", primary: true, onClick: () => reply("transporte.termo_veiculo_proprio_ciente", true) },
            { label: "Não", onClick: () => reply("transporte.termo_veiculo_proprio_ciente", false) },
          ]
        );
        return;
      }

      // Flags e justificativas condicionais
      if (s === "flags.check") {
        computeFlags();
        const f = d.flags;
        const lines = [];
        if (f.envolve_fds_feriado_ou_dia_anterior) lines.push("• Envolve fim de semana/feriado/dia anterior: SIM");
        else lines.push("• Envolve fim de semana/feriado/dia anterior: NÃO");
        if (f.fora_do_prazo) lines.push("• Fora do prazo: SIM");
        else lines.push("• Fora do prazo: NÃO");

        askQuick(
          "Antes de finalizar, vou checar condições especiais.\n" + lines.join("\n") +
          "\n\nSe houver feriado ou saída no dia anterior e eu não detectei, você pode marcar manualmente.",
          [
            {
              label: (d._manual_feriado_dia_anterior ? "✓ " : "") + "Marcar: feriado/dia anterior", onClick: () => {
                d._manual_feriado_dia_anterior = !d._manual_feriado_dia_anterior;
                computeFlags();
                ask();
              }
            },
            {
              label: "Continuar", primary: true, onClick: () => {
                // valida timeline e direciona
                const errs = validateTimeline();
                if (errs.length) {
                  addBubble("bot", "Encontrei inconsistências:\n" + errs.map(e => "• " + e).join("\n") + "\nVamos corrigir as datas.");
                  chatFull.state = "trechos.ida.data_hora";
                  ask();
                  return;
                }

                computeFlags();
                if (d.flags.envolve_fds_feriado_ou_dia_anterior) {
                  chatFull.state = "justificativas.fds";
                  ask();
                  return;
                }
                if (d.flags.fora_do_prazo) {
                  chatFull.state = "justificativas.prazo";
                  ask();
                  return;
                }
                chatFull.state = "summary";
                ask();
              }
            }
          ]
        );
        return;
      }

      if (s === "justificativas.fds") {
        askText("Informe a justificativa (fim de semana/feriado/dia anterior).");
        return;
      }

      if (s === "justificativas.prazo") {
        askText("Informe a justificativa de fora do prazo.");
        return;
      }

      if (s === "summary") {
        computeFlags();
        const f = d.flags;

        const resumo =
          `Resumo para aplicar no formulário:
• Tipo: ${d.tipo_solicitacao}
• Data solicitação: ${d.data_solicitacao}

• Servidor: ${d.servidor.nome_completo} | ${d.servidor.cargo_funcao}
• CPF: ${d.servidor.cpf ? (d.servidor.cpf.slice(0, 3) + "***" + d.servidor.cpf.slice(-2)) : "—"} | SIAPE: ${d.servidor.siape}

• Ida: ${d.trechos.ida.origem} → ${d.trechos.ida.destino} | ${d.trechos.ida.data_hora}
• Retorno: ${d.trechos.retorno.origem} → ${d.trechos.retorno.destino} | ${d.trechos.retorno.data_hora}

• Missão: ${d.missao.inicio_data_hora} até ${d.missao.termino_data_hora}
• Débito: ${d.debito_recurso.tipo}${d.debito_recurso.detalhe ? " (" + d.debito_recurso.detalhe + ")" : ""}
• Transporte: ${d.transporte.meios.join(", ")}${d.transporte.meios.includes("veiculo_proprio") ? (" | termo: " + (d.transporte.termo_veiculo_proprio_ciente ? "ciente" : "NÃO")) : ""}

• Flags:
  - envolve_fds/feriado/dia anterior: ${f.envolve_fds_feriado_ou_dia_anterior ? "SIM" : "NÃO"}
  - fora do prazo: ${f.fora_do_prazo ? "SIM" : "NÃO"}

Depois disso, você pode revisar os campos no formulário e gerar o DOC/PDF.`;

        askQuick(resumo, [
          {
            label: "Aplicar no formulário", primary: true, onClick: () => {
              const payload = buildPayloadFromChatFull();
              finalizeChatAnexo1(payload);
            }
          },
          { label: "Corrigir dados pessoais", onClick: () => { chatFull.state = "servidor.nome_completo"; ask(); } },
          { label: "Corrigir datas da viagem", onClick: () => { chatFull.state = "trechos.ida.data_hora"; ask(); } },
          { label: "Corrigir motivo", onClick: () => { chatFull.state = "motivo_viagem"; ask(); } },
        ]);
        return;
      }
    }

    function reply(field, value) {
      // mensagem do usuário
      addBubble("user", String(value));

      const d = chatFull.data;

      // roteamento + validações por campo
      const fail = (msg) => { addBubble("bot", msg); ask(); };

      // helpers de set em paths
      const setPath = (path, val) => {
        const parts = path.split(".");
        let cur = d;
        for (let i = 0; i < parts.length - 1; i++) {
          cur = cur[parts[i]];
        }
        cur[parts[parts.length - 1]] = val;
      };

      // Transições principais
      if (field === "tipo_solicitacao") {
        d.tipo_solicitacao = value;
        chatFull.state = "data_solicitacao";
        ask();
        return;
      }

      if (chatFull.state === "data_solicitacao") {
        d.data_solicitacao = value;
        chatFull.state = "servidor.nome_completo";
        ask();
        return;
      }

      // Dados pessoais
      if (chatFull.state === "servidor.nome_completo") {
        if (!isMinMax(value, 3, 120)) return fail("Nome inválido. Informe o nome completo (mín. 3 caracteres).");
        setPath("servidor.nome_completo", value.trim());
        chatFull.state = "servidor.cargo_funcao"; ask(); return;
      }
      if (chatFull.state === "servidor.cargo_funcao") {
        if (!isMinMax(value, 2, 80)) return fail("Cargo/função inválido.");
        setPath("servidor.cargo_funcao", value.trim());
        chatFull.state = "servidor.cpf"; ask(); return;
      }
      if (chatFull.state === "servidor.cpf") {
        const cpf = onlyDigits(value);
        if (!/^[0-9]{11}$/.test(cpf)) return fail("CPF deve ter 11 dígitos (somente números).");
        if (!isCPF(cpf)) return fail("CPF inválido (dígitos verificadores não conferem).");
        setPath("servidor.cpf", cpf);
        chatFull.state = "servidor.rg"; ask(); return;
      }
      if (chatFull.state === "servidor.rg") {
        if (!isRG(value)) return fail("RG inválido.");
        setPath("servidor.rg", value.trim());
        chatFull.state = "servidor.data_nascimento"; ask(); return;
      }
      if (chatFull.state === "servidor.siape") {
        const siape = onlyDigits(value);
        if (!isSiape(siape)) return fail("SIAPE inválido (somente números, 4 a 15 dígitos).");
        setPath("servidor.siape", siape);
        chatFull.state = "servidor.nome_mae"; ask(); return;
      }
      if (chatFull.state === "servidor.nome_mae") {
        if (!isMinMax(value, 3, 120)) return fail("Nome da mãe inválido.");
        setPath("servidor.nome_mae", value.trim());
        chatFull.state = "servidor.endereco"; ask(); return;
      }
      if (chatFull.state === "servidor.endereco") {
        if (!isMinMax(value, 5, 200)) return fail("Endereço inválido (muito curto).");
        setPath("servidor.endereco", value.trim());
        chatFull.state = "servidor.telefone"; ask(); return;
      }
      if (chatFull.state === "servidor.telefone") {
        const tel = onlyDigits(value);
        if (!isPhoneDigits(tel)) return fail("Telefone inválido. Informe DDD + número (10 ou 11 dígitos).");
        setPath("servidor.telefone", tel);
        chatFull.state = "servidor.email"; ask(); return;
      }
      if (chatFull.state === "servidor.email") {
        if (!isEmail(value)) return fail("E-mail inválido.");
        setPath("servidor.email", value.trim());
        chatFull.state = "servidor.banco"; ask(); return;
      }
      if (chatFull.state === "servidor.banco") {
        if (!isMinMax(value, 2, 40)) return fail("Banco inválido.");
        setPath("servidor.dados_bancarios.banco", value.trim());
        chatFull.state = "servidor.agencia"; ask(); return;
      }
      if (chatFull.state === "servidor.agencia") {
        const ag = onlyDigits(value);
        if (!isNumLen(ag, 1, 10)) return fail("Agência inválida (somente números).");
        setPath("servidor.dados_bancarios.agencia", ag);
        chatFull.state = "servidor.conta"; ask(); return;
      }
      if (chatFull.state === "servidor.conta") {
        const ct = onlyDigits(value);
        if (!isNumLen(ct, 1, 20)) return fail("Conta inválida (somente números).");
        setPath("servidor.dados_bancarios.conta", ct);
        chatFull.state = "trechos.ida.origem"; ask(); return;
      }

      // Datas (date/datetime) — tratadas nos handlers específicos abaixo
      // Trechos e missão textos
      if (chatFull.state === "trechos.ida.origem") {
        if (!isMinMax(value, 2, 80)) return fail("Origem inválida.");
        setPath("trechos.ida.origem", value.trim());
        chatFull.state = "trechos.ida.destino"; ask(); return;
      }
      if (chatFull.state === "trechos.ida.destino") {
        if (!isMinMax(value, 2, 80)) return fail("Destino inválido.");
        setPath("trechos.ida.destino", value.trim());
        chatFull.state = "trechos.ida.data_hora"; ask(); return;
      }
      if (chatFull.state === "trechos.retorno.origem_text") {
        if (!isMinMax(value, 2, 80)) return fail("Origem do retorno inválida.");
        setPath("trechos.retorno.origem", value.trim());
        chatFull.state = "trechos.retorno.destino"; ask(); return;
      }
      if (chatFull.state === "trechos.retorno.destino_text") {
        if (!isMinMax(value, 2, 80)) return fail("Destino do retorno inválido.");
        setPath("trechos.retorno.destino", value.trim());
        chatFull.state = "trechos.retorno.data_hora"; ask(); return;
      }

      // Motivo
      if (chatFull.state === "motivo.objetivo_curto") {
        if (!isMinMax(value, 5, 200)) return fail("Objetivo muito curto. Escreva uma frase com pelo menos 5 caracteres.");
        const idaCity = d.trechos.ida.destino || "destino";
        const idaDate = d.trechos.ida.data_hora ? d.trechos.ida.data_hora.split("T")[0] : "—";
        const retDate = d.trechos.retorno.data_hora ? d.trechos.retorno.data_hora.split("T")[0] : "—";

        const tipo = d._motivo_modelo;
        let base = "Participação em atividade institucional";
        if (tipo === "evento") base = "Participação em evento técnico/científico";
        if (tipo === "capacitacao") base = "Participação em capacitação/treinamento";
        if (tipo === "reuniao") base = "Participação em reunião técnica/institucional";
        if (tipo === "visita") base = "Realização de visita técnica";

        d.motivo_viagem = `${base} em ${idaCity}, no período de ${idaDate} a ${retDate}, com objetivo de ${value.trim()}.`;
        chatFull.state = "debito_recurso.tipo"; ask(); return;
      }

      if (chatFull.state === "motivo.texto_livre") {
        if (!isMinMax(value, 20, 2000)) return fail("Motivo muito curto. Informe ao menos 20 caracteres.");
        d.motivo_viagem = value.trim();
        chatFull.state = "debito_recurso.tipo"; ask(); return;
      }

      // Débito
      if (field === "debito_recurso.tipo") {
        d.debito_recurso.tipo = value;
        if (value === "projeto" || value === "outros") {
          chatFull.state = "debito_recurso.detalhe"; ask(); return;
        }
        d.debito_recurso.detalhe = null;
        chatFull.state = "transporte.meios"; ask(); return;
      }
      if (chatFull.state === "debito_recurso.detalhe") {
        if (!isMinMax(value, 2, 200)) return fail("Detalhe inválido (mín. 2 caracteres).");
        d.debito_recurso.detalhe = value.trim();
        chatFull.state = "transporte.meios"; ask(); return;
      }

      // Justificativas
      if (chatFull.state === "justificativas.fds") {
        if (!isMinMax(value, 10, 2000)) return fail("Justificativa curta. Informe pelo menos 10 caracteres.");
        d.justificativas.justificativa_fds_feriado_dia_anterior = value.trim();

        // ainda pode precisar de fora do prazo
        computeFlags();
        if (d.flags.fora_do_prazo) {
          chatFull.state = "justificativas.prazo"; ask(); return;
        }
        chatFull.state = "summary"; ask(); return;
      }

      if (chatFull.state === "justificativas.prazo") {
        if (!isMinMax(value, 10, 2000)) return fail("Justificativa curta. Informe pelo menos 10 caracteres.");
        d.justificativas.justificativa_fora_prazo = value.trim();
        chatFull.state = "summary"; ask(); return;
      }

      // Transporte termo
      if (field === "transporte.termo_veiculo_proprio_ciente") {
        if (value !== true) {
          addBubble("bot", "Sem a ciência do termo, eu não posso manter veículo próprio. Vou desmarcar veículo próprio.");
          d.transporte.meios = d.transporte.meios.filter(x => x !== "veiculo_proprio");
          d.transporte.termo_veiculo_proprio_ciente = null;
        } else {
          d.transporte.termo_veiculo_proprio_ciente = true;
        }
        chatFull.state = "flags.check"; ask(); return;
      }

      ask();
    }

    /* Handlers dos pickers (date/datetime) */
    m.dateOk.addEventListener("click", () => {
      const v = m.date.value;
      if (!v) return;
      addBubble("user", v);

      if (chatFull.state === "data_solicitacao") {
        reply("data_solicitacao", v);
        return;
      }
      if (chatFull.state === "servidor.data_nascimento") {
        chatFull.data.servidor.data_nascimento = v;
        chatFull.state = "servidor.siape";
        ask();
        return;
      }
    });

    m.dtOk.addEventListener("click", () => {
      const v = m.dt.value;
      if (!v) return;
      addBubble("user", v);

      const d = chatFull.data;

      if (chatFull.state === "trechos.ida.data_hora") {
        d.trechos.ida.data_hora = v;
        computeFlags();
        chatFull.state = "trechos.retorno.origem";
        ask();
        return;
      }
      if (chatFull.state === "trechos.retorno.data_hora") {
        d.trechos.retorno.data_hora = v;

        const errs = validateTimeline();
        if (errs.length) {
          addBubble("bot", "Tem um problema nas datas:\n" + errs.map(e => "• " + e).join("\n") + "\nVamos corrigir. Informe novamente a data/hora do retorno.");
          chatFull.state = "trechos.retorno.data_hora";
          ask();
          return;
        }

        computeFlags();
        chatFull.state = "missao.inicio_data_hora";
        ask();
        return;
      }
      if (chatFull.state === "missao.inicio_data_hora") {
        d.missao.inicio_data_hora = v;
        chatFull.state = "missao.termino_data_hora";
        ask();
        return;
      }
      if (chatFull.state === "missao.termino_data_hora") {
        d.missao.termino_data_hora = v;

        const errs = validateTimeline();
        if (errs.length) {
          addBubble("bot", "Algo não fecha:\n" + errs.map(e => "• " + e).join("\n") + "\nVamos ajustar a missão. Informe novamente o término da missão.");
          chatFull.state = "missao.termino_data_hora";
          ask();
          return;
        }

        chatFull.state = "motivo_viagem";
        ask();
        return;
      }
    });

    /* Handler texto */
    m.send.addEventListener("click", () => {
      const v = (m.text.value || "").trim();
      if (!v) return;
      addBubble("user", v);

      // roteamento do texto conforme estado
      if (chatFull.state === "servidor.nome_completo"
        || chatFull.state === "servidor.cargo_funcao"
        || chatFull.state === "servidor.cpf"
        || chatFull.state === "servidor.rg"
        || chatFull.state === "servidor.siape"
        || chatFull.state === "servidor.nome_mae"
        || chatFull.state === "servidor.endereco"
        || chatFull.state === "servidor.telefone"
        || chatFull.state === "servidor.email"
        || chatFull.state === "servidor.banco"
        || chatFull.state === "servidor.agencia"
        || chatFull.state === "servidor.conta"
        || chatFull.state === "trechos.ida.origem"
        || chatFull.state === "trechos.ida.destino"
        || chatFull.state === "trechos.retorno.origem_text"
        || chatFull.state === "trechos.retorno.destino_text"
        || chatFull.state === "debito_recurso.detalhe"
        || chatFull.state === "motivo.objetivo_curto"
        || chatFull.state === "motivo.texto_livre"
        || chatFull.state === "justificativas.fds"
        || chatFull.state === "justificativas.prazo"
      ) {
        // Para "motivo.modelo", o texto não entra aqui; ele é quick
        reply(chatFull.state, v);
      }

      m.text.value = "";
    });

    /* Tratamento do motivo por modelo (quick) */
    function replyMotivoModelo(tipo) {
      chatFull.data._motivo_modelo = tipo;
      addBubble("user", ({
        evento: "Evento", capacitacao: "Capacitação", reuniao: "Reunião", visita: "Visita técnica"
      })[tipo] || tipo);

      chatFull.state = "motivo.objetivo_curto";
      ask();
    }

    /* Ajuste do reply para motivo.modelo */
    const originalReply = reply;
    reply = function (field, value) {
      // interceptar motivo.modelo
      if (field === "motivo.modelo") {
        replyMotivoModelo(value);
        return;
      }
      originalReply(field, value);
    };

    /* Aplicar dados no formulário principal */
    function applyToForm() {
      computeFlags();
      const d = chatFull.data;

      const payload = {
        tipo_solicitacao: d.tipo_solicitacao,
        data_solicitacao: d.data_solicitacao,
        servidor: d.servidor,
        motivo_viagem: d.motivo_viagem,
        trechos: {
          ida: {
            origem: d.trechos.ida.origem,
            destino: d.trechos.ida.destino,
            data_hora: d.trechos.ida.data_hora ? (d.trechos.ida.data_hora + ":00") : null
          },
          retorno: {
            origem: d.trechos.retorno.origem,
            destino: d.trechos.retorno.destino,
            data_hora: d.trechos.retorno.data_hora ? (d.trechos.retorno.data_hora + ":00") : null
          }
        },
        missao: {
          inicio_data_hora: d.missao.inicio_data_hora ? (d.missao.inicio_data_hora + ":00") : null,
          termino_data_hora: d.missao.termino_data_hora ? (d.missao.termino_data_hora + ":00") : null
        },
        debito_recurso: d.debito_recurso,
        transporte: d.transporte,
        flags: d.flags,
        justificativas: {}
      };

      if (d.flags.envolve_fds_feriado_ou_dia_anterior) {
        payload.justificativas.justificativa_fds_feriado_dia_anterior = d.justificativas.justificativa_fds_feriado_dia_anterior || "";
      }
      if (d.flags.fora_do_prazo) {
        payload.justificativas.justificativa_fora_prazo = d.justificativas.justificativa_fora_prazo || "";
      }
      if (Object.keys(payload.justificativas).length === 0) {
        delete payload.justificativas;
      }

      // usa sua função existente (se já tem) ou seta campo a campo:
      if (typeof applyPrefill === "function") {
        applyPrefill(payload);
      } else {
        // fallback: set by name
        const setVal = (name, val) => {
          const el = document.querySelector(`[name="${name}"]`);
          if (!el) return;
          if (el.type === "datetime-local" && typeof val === "string") el.value = val.slice(0, 16);
          else el.value = val ?? "";
        };
        // implemente conforme necessário
      }

      addBubble("bot", "Pronto. Apliquei os dados no formulário. Agora você pode revisar e gerar o documento.");
      m.modal.style.display = "none";

      // vai para um passo útil (motivo/justificativas)
      const downloadModal = document.getElementById("downloadModal");
      const downloadClose = document.getElementById("downloadClose");
      const downloadSummary = document.getElementById("downloadSummary");
      const btnReviewForm = document.getElementById("btnReviewForm");
      const btnDownloadDOCX = document.getElementById("btnDownloadDOCX");
      const btnDownloadPDF = document.getElementById("btnDownloadPDF");

      downloadClose.addEventListener("click", () => downloadModal.style.display = "none");

      btnReviewForm.addEventListener("click", () => {
        downloadModal.style.display = "none";
        // se quiser ir para uma etapa específica:
        gotoStep(0);
      });

      function openDownloadModal(payload) {
        // resumo simples (mascara CPF)
        const cpf = payload?.servidor?.cpf || "";
        const cpfMask = cpf && cpf.length === 11 ? (cpf.slice(0, 3) + "***" + cpf.slice(-2)) : "—";
        downloadSummary.textContent =
          `Servidor: ${payload?.servidor?.nome_completo || "—"} | CPF: ${cpfMask}\n` +
          `Ida: ${payload?.trechos?.ida?.origem || "—"} → ${payload?.trechos?.ida?.destino || "—"} | ${payload?.trechos?.ida?.data_hora || "—"}\n` +
          `Retorno: ${payload?.trechos?.retorno?.origem || "—"} → ${payload?.trechos?.retorno?.destino || "—"} | ${payload?.trechos?.retorno?.data_hora || "—"}`;

        downloadModal.style.display = "block";
      }

      // Esta função deve chamar seu backend e baixar arquivo
      async function downloadAnexo1(format, payload) {
        // Ajuste o endpoint conforme o seu backend atual.
        // Opção A (com query): POST /api/anexo1/generate?format=pdf|docx
        // Opção B (no body): POST /api/anexo1/generate  {format, payload}

        const url = `/api/anexo1/generate?format=${encodeURIComponent(format)}`;

        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          alert("Falha ao gerar o documento. " + txt);
          return;
        }

        // se o backend devolver arquivo (blob):
        const blob = await res.blob();
        const a = document.createElement("a");
        const objUrl = URL.createObjectURL(blob);
        a.href = objUrl;
        a.download = (format === "pdf") ? "anexo1.pdf" : "anexo1.docx";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(objUrl);
      }

      btnDownloadDOCX.addEventListener("click", async () => {
        const payload = window.__lastChatPayloadAnexo1;
        if (!payload) { alert("Sem dados para gerar. Rode o assistente novamente."); return; }
        await downloadAnexo1("docx", payload);
      });

      btnDownloadPDF.addEventListener("click", async () => {
        const payload = window.__lastChatPayloadAnexo1;
        if (!payload) { alert("Sem dados para gerar. Rode o assistente novamente."); return; }
        await downloadAnexo1("pdf", payload);
      });


    }

    function buildPayloadFromChatFull() {
      // sempre monta do estado atual do chat
      const d = chatFull.data;
      computeFlags();

      const payload = {
        tipo_solicitacao: d.tipo_solicitacao,
        data_solicitacao: d.data_solicitacao,
        servidor: {
          nome_completo: d.servidor.nome_completo,
          cargo_funcao: d.servidor.cargo_funcao,
          cpf: d.servidor.cpf,
          rg: d.servidor.rg,
          data_nascimento: d.servidor.data_nascimento,
          siape: d.servidor.siape,
          nome_mae: d.servidor.nome_mae,
          endereco: d.servidor.endereco,
          telefone: d.servidor.telefone,
          email: d.servidor.email,
          dados_bancarios: {
            banco: d.servidor.dados_bancarios.banco,
            agencia: d.servidor.dados_bancarios.agencia,
            conta: d.servidor.dados_bancarios.conta
          }
        },
        motivo_viagem: d.motivo_viagem,
        trechos: {
          ida: {
            origem: d.trechos.ida.origem,
            destino: d.trechos.ida.destino,
            data_hora: d.trechos.ida.data_hora ? (d.trechos.ida.data_hora + ":00") : null
          },
          retorno: {
            origem: d.trechos.retorno.origem,
            destino: d.trechos.retorno.destino,
            data_hora: d.trechos.retorno.data_hora ? (d.trechos.retorno.data_hora + ":00") : null
          }
        },
        missao: {
          inicio_data_hora: d.missao.inicio_data_hora ? (d.missao.inicio_data_hora + ":00") : null,
          termino_data_hora: d.missao.termino_data_hora ? (d.missao.termino_data_hora + ":00") : null
        },
        debito_recurso: (d.debito_recurso.tipo === "projeto" || d.debito_recurso.tipo === "outros")
          ? { tipo: d.debito_recurso.tipo, detalhe: d.debito_recurso.detalhe }
          : { tipo: d.debito_recurso.tipo, detalhe: "" },
        transporte: d.transporte.meios.includes("veiculo_proprio")
          ? { meios: d.transporte.meios, termo_veiculo_proprio_ciente: !!d.transporte.termo_veiculo_proprio_ciente }
          : { meios: d.transporte.meios },
        flags: {
          envolve_fds_feriado_ou_dia_anterior: !!d.flags.envolve_fds_feriado_ou_dia_anterior,
          fora_do_prazo: !!d.flags.fora_do_prazo
        }
      };

      // justificativas só se necessário
      if (payload.flags.envolve_fds_feriado_ou_dia_anterior || payload.flags.fora_do_prazo) {
        payload.justificativas = {};
        if (payload.flags.envolve_fds_feriado_ou_dia_anterior) {
          payload.justificativas.justificativa_fds_feriado_dia_anterior =
            d.justificativas.justificativa_fds_feriado_dia_anterior || "";
        }
        if (payload.flags.fora_do_prazo) {
          payload.justificativas.justificativa_fora_prazo =
            d.justificativas.justificativa_fora_prazo || "";
        }
      }

      return payload;
    }


    /* Abrir/fechar */
    m.open.addEventListener("click", () => {
      m.tl.innerHTML = "";
      chatFull.state = "start";
      // reset data
      chatFull.data = JSON.parse(JSON.stringify({
        tipo_solicitacao: null,
        data_solicitacao: null,
        servidor: {
          nome_completo: null, cargo_funcao: null, cpf: null, rg: null, data_nascimento: null,
          siape: null, nome_mae: null, endereco: null, telefone: null, email: null,
          dados_bancarios: { banco: null, agencia: null, conta: null }
        },
        motivo_viagem: null,
        trechos: { ida: { origem: null, destino: null, data_hora: null }, retorno: { origem: null, destino: null, data_hora: null } },
        missao: { inicio_data_hora: null, termino_data_hora: null },
        debito_recurso: { tipo: null, detalhe: null },
        transporte: { meios: [], termo_veiculo_proprio_ciente: null },
        flags: { envolve_fds_feriado_ou_dia_anterior: false, fora_do_prazo: false },
        justificativas: { justificativa_fds_feriado_dia_anterior: null, justificativa_fora_prazo: null },
        _manual_feriado_dia_anterior: false
      }));

      m.modal.style.display = "block";
      ask();
    });

    m.close.addEventListener("click", () => { m.modal.style.display = "none"; });

    /* Ajuste de modos ao perguntar */
    (function () {
      const oldAsk = ask;
      ask = function () {
        // decide modo pelo estado
        const s = chatFull.state;
        if (
          s === "start" ||
          s === "trechos.retorno.origem" ||
          s === "trechos.retorno.destino" ||
          s === "motivo_viagem" ||
          s === "motivo.modelo" ||
          s === "debito_recurso.tipo" ||
          s === "transporte.meios" ||
          s === "transporte.termo" ||
          s === "flags.check" ||
          s === "summary"
        ) setMode("quick");
        else if (
          s === "data_solicitacao" || s === "servidor.data_nascimento"
        ) setMode("date");
        else if (
          s === "trechos.ida.data_hora" || s === "trechos.retorno.data_hora" ||
          s === "missao.inicio_data_hora" || s === "missao.termino_data_hora"
        ) setMode("datetime");
        else setMode("text");

        oldAsk();
      }
    })();

    function finalizeChatAnexo1(payload) {
      // aplica no form
      if (typeof applyPrefill === "function") applyPrefill(payload);
      if (typeof applyPayloadToFormByName === "function") applyPayloadToFormByName(payload);

      // salva para download
      window.__lastChatPayloadAnexo1 = payload;

      // fecha chat e abre modal download
      document.getElementById("chatFullModal").style.display = "none";
      openDownloadModal(payload);
    }




    /* ---------------- Conditional UI ---------------- */
    const debTipoEl = document.getElementById("deb_tipo");
    const debWrap = document.getElementById("debDetalheWrap");
    const chkVeicProprio = document.getElementById("chkVeicProprio");
    const termoWrap = document.getElementById("termoWrap");
    const flagFdsEl = document.getElementById("flagFds");
    const wrapJustFds = document.getElementById("wrapJustFds");
    const flagPrazoEl = document.getElementById("flagPrazo");
    const wrapJustPrazo = document.getElementById("wrapJustPrazo");

    debTipoEl.addEventListener("change", () => {
      const v = debTipoEl.value;
      const show = (v === "projeto" || v === "outros");
      debWrap.style.display = show ? "block" : "none";
      if (!show) document.getElementById("deb_det").value = "";
    });

    chkVeicProprio.addEventListener("change", () => {
      termoWrap.style.display = chkVeicProprio.checked ? "block" : "none";
      if (!chkVeicProprio.checked) document.getElementById("termoCiente").checked = false;
    });

    flagFdsEl.addEventListener("change", () => {
      wrapJustFds.style.display = flagFdsEl.checked ? "block" : "none";
      if (!flagFdsEl.checked) document.getElementById("justFds").value = "";
    });

    function setPrazoUI(isFora) {
      flagPrazoEl.checked = !!isFora;
      wrapJustPrazo.style.display = isFora ? "block" : "none";
      const badgePrazo = document.getElementById("badgePrazo");
      badgePrazo.textContent = isFora ? "Fora do prazo: SIM" : "Fora do prazo: NÃO";
      badgePrazo.className = "badge " + (isFora ? "danger" : "success");
    }

    /* ---------------- Payload builder ---------------- */
    function normalizeDT(s) {
      if (!s) return s;
      return (s.length === 16) ? (s + ":00") : s; // datetime-local => ISO-like
    }

    function setDeep(obj, path, value) {
      const parts = path.split(".");
      let cur = obj;
      for (let i = 0; i < parts.length - 1; i++) {
        if (typeof cur[parts[i]] !== "object" || cur[parts[i]] === null) cur[parts[i]] = {};
        cur = cur[parts[i]];
      }
      cur[parts[parts.length - 1]] = value;
    }

    function formToJSON() {
      const fd = new FormData(form);
      const obj = {};

      // transporte.meios
      const meios = Array.from(form.querySelectorAll('input[name="transporte.meios"]:checked')).map(x => x.value);
      obj.transporte = obj.transporte || {};
      obj.transporte.meios = meios;

      // texto e selects
      for (const [k, v] of fd.entries()) {
        if (k === "transporte.meios") continue;

        if (k.startsWith("flags.")) {
          setDeep(obj, k, true);
          continue;
        }
        if (k === "transporte.termo_veiculo_proprio_ciente") {
          setDeep(obj, k, true);
          continue;
        }
        setDeep(obj, k, v);
      }

      // boolean defaults
      obj.flags = obj.flags || {};
      obj.flags.envolve_fds_feriado_ou_dia_anterior = !!obj.flags.envolve_fds_feriado_ou_dia_anterior;
      obj.flags.fora_do_prazo = !!obj.flags.fora_do_prazo;

      obj.transporte = obj.transporte || {};
      obj.transporte.termo_veiculo_proprio_ciente = !!obj.transporte.termo_veiculo_proprio_ciente;

      // normalize date-time fields
      try {
        obj.trechos.ida.data_hora = normalizeDT(obj.trechos.ida.data_hora);
        obj.trechos.retorno.data_hora = normalizeDT(obj.trechos.retorno.data_hora);
        obj.missao.inicio_data_hora = normalizeDT(obj.missao.inicio_data_hora);
        obj.missao.termino_data_hora = normalizeDT(obj.missao.termino_data_hora);
      } catch (e) { }

      // ensure justificativas object exists if any text
      const jf = (obj.justificativas && obj.justificativas.justificativa_fds_feriado_dia_anterior) ? obj.justificativas.justificativa_fds_feriado_dia_anterior.trim() : "";
      const jp = (obj.justificativas && obj.justificativas.justificativa_fora_prazo) ? obj.justificativas.justificativa_fora_prazo.trim() : "";
      if (!obj.justificativas && (jf || jp)) obj.justificativas = {};

      return obj;
    }

    /* ---------------- Auto flags ---------------- */
    function refreshAutoFlags() {
      // auto weekend flag from ida date
      const idaEl = form.querySelector('[name="trechos.ida.data_hora"]');
      const tipoEl = form.querySelector('[name="tipo_solicitacao"]');
      const dataSolicEl = form.querySelector('[name="data_solicitacao"]');
      const badgeFds = document.getElementById("badgeFds");

      const ida = idaEl.value ? new Date(idaEl.value) : null;

      if (ida) {
        const wd = ida.getDay(); // 0 dom ... 6 sab
        const isWeekend = (wd === 0 || wd === 6);
        // só seta automaticamente se o usuário ainda não marcou por conta própria
        if (!flagFdsEl.checked && isWeekend) {
          flagFdsEl.checked = true;
          wrapJustFds.style.display = "block";
        }
        badgeFds.textContent = isWeekend ? "Fim de semana: SIM" : "Fim de semana: NÃO";
        badgeFds.className = "badge " + (isWeekend ? "warn" : "success");
      } else {
        badgeFds.textContent = "Fim de semana: —";
        badgeFds.className = "badge";
      }

      // auto fora do prazo (front-end approximation; backend is source of truth)
      // regra: data_limite = date(ida) - (30 se tem passagens, senão 10)
      const tipo = tipoEl.value;
      const hasPass = (tipo === "passagens" || tipo === "diarias_e_passagens");
      const prazo = hasPass ? 30 : 10;

      if (ida && dataSolicEl.value) {
        const ds = new Date(dataSolicEl.value + "T00:00:00");
        const limite = new Date(ida);
        limite.setHours(0, 0, 0, 0);
        limite.setDate(limite.getDate() - prazo);

        const isFora = ds > limite;
        setPrazoUI(isFora);
      } else {
        setPrazoUI(false);
        document.getElementById("badgePrazo").textContent = "Fora do prazo: —";
        document.getElementById("badgePrazo").className = "badge";
      }
    }

    /* ---------------- Review ---------------- */
    function renderReview() {
      refreshAutoFlags();

      const p = formToJSON();
      const lines = [];

      function line(label, value) {
        lines.push(`${label}: ${value || "—"}`);
      }

      line("Tipo", p.tipo_solicitacao);
      line("Data da solicitação", p.data_solicitacao);

      lines.push("\n[Servidor]");
      line("Nome", p.servidor?.nome_completo);
      line("Cargo/Função", p.servidor?.cargo_funcao);
      line("CPF", p.servidor?.cpf);
      line("SIAPE", p.servidor?.siape);
      line("E-mail", p.servidor?.email);

      lines.push("\n[Viagem]");
      line("Ida", `${p.trechos?.ida?.origem || "—"} → ${p.trechos?.ida?.destino || "—"} | ${p.trechos?.ida?.data_hora || "—"}`);
      line("Retorno", `${p.trechos?.retorno?.origem || "—"} → ${p.trechos?.retorno?.destino || "—"} | ${p.trechos?.retorno?.data_hora || "—"}`);

      lines.push("\n[Missão]");
      line("Início", p.missao?.inicio_data_hora);
      line("Término", p.missao?.termino_data_hora);

      lines.push("\n[Recurso]");
      line("Tipo", p.debito_recurso?.tipo);
      line("Detalhe", p.debito_recurso?.detalhe);

      lines.push("\n[Transporte]");
      line("Meios", (p.transporte?.meios || []).join(", "));

      lines.push("\n[Justificativas]");
      line("Fim de semana/feriado/dia anterior (flag)", String(!!p.flags?.envolve_fds_feriado_ou_dia_anterior));
      line("Fora do prazo (flag)", String(!!p.flags?.fora_do_prazo));
      line("Just. FDS", p.justificativas?.justificativa_fds_feriado_dia_anterior);
      line("Just. Prazo", p.justificativas?.justificativa_fora_prazo);

      document.getElementById("reviewText").textContent = lines.join("\n");

      const badge = document.getElementById("reviewBadge");
      if (p.flags?.fora_do_prazo) {
        badge.textContent = "Atenção: fora do prazo";
        badge.className = "badge danger";
      } else {
        badge.textContent = "Pronto para gerar";
        badge.className = "badge success";
      }
    }

    /* ---------------- Submit (generate) ---------------- */
    async function generate(format) {
      showErrors(null);
      setStatus("Validando...", "");

      const payload = formToJSON();

      // backend é fonte de verdade: preview/validate antes de gerar
      const previewRes = await fetch("/api/anexo1/preview", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const previewJson = await previewRes.json().catch(() => null);

      if (!previewRes.ok || !previewJson) {
        setStatus("Erro", "danger");
        showErrors(["Falha ao validar os dados."]);
        return;
      }

      if (previewJson.ok === false) {
        setStatus("Correção necessária", "warn");
        const msgs = (previewJson.errors || []).map(e => e.message);
        showErrors(msgs.length ? msgs : ["Revise os campos."]);
        // leva para um passo provável conforme campo
        const first = (previewJson.errors && previewJson.errors[0] && previewJson.errors[0].field) ? previewJson.errors[0].field : "";
        if (first.startsWith("trechos")) gotoStep(5);
        else if (first.startsWith("missao")) gotoStep(6);
        else if (first.startsWith("justificativas")) gotoStep(8);
        else gotoStep(2);
        return;
      }

      setStatus("Gerando...", "");
      const genRes = await fetch(`/api/anexo1/generate?format=${format}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!genRes.ok) {
        const err = await genRes.json().catch(() => null);
        setStatus("Erro", "danger");
        const detail = err?.detail || err;
        const msgs = (detail?.errors || []).map(e => e.message);
        showErrors(msgs.length ? msgs : ["Falha ao gerar o documento."]);
        return;
      }

      const blob = await genRes.blob();
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = (format === "pdf") ? "anexo1_preenchido.pdf" : "anexo1_preenchido.docx";
      document.body.appendChild(a);
      a.click();
      a.remove();

      setStatus("Gerado com sucesso", "success");
    }

    /* ---------------- Buttons ---------------- */
    document.getElementById("btnBack").addEventListener("click", () => {
      gotoStep(current - 1);
    });

    document.getElementById("btnNext").addEventListener("click", () => {
      // validate current before advancing
      if (!validateStep(current)) return;

      if (current === total) {
        // Finalizar: vai para revisão e mantém ali
        gotoStep(total);
        return;
      }
      gotoStep(current + 1);
    });

    document.getElementById("btnDocx").addEventListener("click", async () => {
      // validate all steps quickly before generate
      for (let i = 1; i <= 8; i++) {
        if (!validateStep(i)) {
          gotoStep(i);
          return;
        }
      }
      await generate("docx");
    });
    document.getElementById("btnPdf").addEventListener("click", async () => {
      for (let i = 1; i <= 8; i++) {
        if (!validateStep(i)) {
          gotoStep(i);
          return;
        }
      }
      await generate("pdf");
    });

    // init
    steps.forEach(s => s.style.display = "none");
    gotoStep(1);
    setStatus("Rascunho", "");


    function applyPrefill(prefill) {
      if (!prefill || typeof prefill !== "object") return;

      function setValue(name, val) {
        const el = form.querySelector(`[name="${name}"]`);
        if (!el) return;

        // datetime-local precisa de "YYYY-MM-DDTHH:MM"
        if (el.type === "datetime-local" && typeof val === "string") {
          el.value = val.slice(0, 16);
          return;
        }
        el.value = val;
      }

      // motivo
      if (prefill.motivo_viagem) setValue("motivo_viagem", prefill.motivo_viagem);

      // trechos
      if (prefill.trechos?.ida) {
        if (prefill.trechos.ida.origem) setValue("trechos.ida.origem", prefill.trechos.ida.origem);
        if (prefill.trechos.ida.destino) setValue("trechos.ida.destino", prefill.trechos.ida.destino);
        if (prefill.trechos.ida.data_hora) setValue("trechos.ida.data_hora", prefill.trechos.ida.data_hora);
      }
      if (prefill.trechos?.retorno) {
        if (prefill.trechos.retorno.origem) setValue("trechos.retorno.origem", prefill.trechos.retorno.origem);
        if (prefill.trechos.retorno.destino) setValue("trechos.retorno.destino", prefill.trechos.retorno.destino);
        if (prefill.trechos.retorno.data_hora) setValue("trechos.retorno.data_hora", prefill.trechos.retorno.data_hora);
      }

      // missão
      if (prefill.missao) {
        if (prefill.missao.inicio_data_hora) setValue("missao.inicio_data_hora", prefill.missao.inicio_data_hora);
        if (prefill.missao.termino_data_hora) setValue("missao.termino_data_hora", prefill.missao.termino_data_hora);
      }

      // flags
      if (typeof prefill.flags?.envolve_fds_feriado_ou_dia_anterior === "boolean") {
        const v = prefill.flags.envolve_fds_feriado_ou_dia_anterior;
        document.getElementById("flagFds").checked = v;
        document.getElementById("wrapJustFds").style.display = v ? "block" : "none";
      }
    }




    /* =========================
   Assistente Guiado (ANEXO I)
   ========================= */

    const guided = {
      step: 0,
      total: 7,
      answers: {
        tipo_solicitacao: "",
        data_solicitacao: "",
        ida_origem: "",
        ida_destino: "",
        ida_dt: "",
        ret_origem: "",
        ret_destino: "",
        ret_dt: "",
        missao_ini: "",
        missao_fim: "",
        deb_tipo: "",
        deb_det: "",
        meios: [],
        veic_proprio_ciente: false
      }
    };

    const guidedModal = document.getElementById("guidedModal");
    const guidedBody = document.getElementById("guidedBody");
    const guidedErrors = document.getElementById("guidedErrors");
    const guidedPill = document.getElementById("guidedStepPill");

    function gShowErrors(msgs) {
      if (!msgs || !msgs.length) {
        guidedErrors.style.display = "none";
        guidedErrors.textContent = "";
        return;
      }
      guidedErrors.style.display = "block";
      guidedErrors.textContent = msgs.map(m => `• ${m}`).join("\n");
    }

    function gSetStep(n) {
      guided.step = Math.max(0, Math.min(guided.total - 1, n));
      guidedPill.textContent = `${guided.step + 1}/${guided.total}`;
      gShowErrors(null);
      guidedBack.disabled = guided.step === 0;
      guidedNext.textContent = (guided.step === guided.total - 1) ? "Aplicar e continuar" : "Avançar";
      renderGuidedStep();
    }

    function renderGuidedStep() {
      const s = guided.step;
      const a = guided.answers;

      // Helpers
      const select = (id, label, options, value) => `
    <label>${label}</label>
    <select id="${id}">
      <option value="">Selecione...</option>
      ${options.map(o => `<option value="${o.value}" ${o.value === value ? "selected" : ""}>${o.label}</option>`).join("")}
    </select>
  `;

      const input = (id, label, type, value, placeholder = "") => `
    <label>${label}</label>
    <input id="${id}" type="${type}" value="${value || ""}" placeholder="${placeholder}">
  `;

      const checkbox = (id, label, checked, small = "") => `
    <label class="checkbox">
      <input id="${id}" type="checkbox" ${checked ? "checked" : ""}>
      <div>
        <span>${label}</span>
        ${small ? `<small>${small}</small>` : ""}
      </div>
    </label>
  `;

      const multiCheckbox = (items) => items.map(it => checkbox(it.id, it.label, it.checked, it.small)).join("");

      // Conteúdo por passo
      if (s === 0) {
        guidedBody.innerHTML = `
      <h2>1) Tipo e data da solicitação</h2>
      ${select("g_tipo", "Tipo de solicitação", [
          { value: "diarias", label: "Diárias" },
          { value: "passagens", label: "Passagens" },
          { value: "diarias_e_passagens", label: "Diárias + Passagens" },
        ], a.tipo_solicitacao)}
      ${input("g_data_sol", "Data da solicitação", "date", a.data_solicitacao)}
      <div class="helper">Prazo será verificado automaticamente pelo sistema (10/30 dias) usando a data da ida.</div>
    `;
        return;
      }

      if (s === 1) {
        guidedBody.innerHTML = `
      <h2>2) Trecho de ida</h2>
      <div class="grid2">
        <div>${input("g_ida_ori", "Origem", "text", a.ida_origem, "Ex.: João Pessoa")}</div>
        <div>${input("g_ida_des", "Destino", "text", a.ida_destino, "Ex.: Recife")}</div>
        <div style="grid-column:1/-1;">${input("g_ida_dt", "Data e hora da ida", "datetime-local", a.ida_dt)}</div>
      </div>
    `;
        return;
      }

      if (s === 2) {
        guidedBody.innerHTML = `
      <h2>3) Trecho de retorno</h2>
      <div class="grid2">
        <div>${input("g_ret_ori", "Origem", "text", a.ret_origem, "Ex.: Recife")}</div>
        <div>${input("g_ret_des", "Destino", "text", a.ret_destino, "Ex.: João Pessoa")}</div>
        <div style="grid-column:1/-1;">${input("g_ret_dt", "Data e hora do retorno", "datetime-local", a.ret_dt)}</div>
      </div>
      <div class="helper">Regra: retorno não pode ser anterior à ida.</div>
    `;
        return;
      }

      if (s === 3) {
        guidedBody.innerHTML = `
      <h2>4) Período da missão</h2>
      <div class="grid2">
        <div>${input("g_mi", "Início da missão", "datetime-local", a.missao_ini)}</div>
        <div>${input("g_mf", "Término da missão", "datetime-local", a.missao_fim)}</div>
      </div>
      <div class="helper">Regras: término ≥ início; início ≥ ida; término ≤ retorno.</div>
      <button type="button" class="btn" id="g_auto_missao">Sugerir automaticamente (ida+2h / retorno-2h)</button>
    `;
        // Hook botão auto
        setTimeout(() => {
          const btn = document.getElementById("g_auto_missao");
          if (btn) {
            btn.addEventListener("click", () => {
              if (!guided.answers.ida_dt || !guided.answers.ret_dt) {
                gShowErrors(["Preencha ida e retorno antes de sugerir a missão."]);
                return;
              }
              const ida = new Date(guided.answers.ida_dt);
              const ret = new Date(guided.answers.ret_dt);
              const mi = new Date(ida.getTime() + 2 * 60 * 60 * 1000);
              const mf = new Date(ret.getTime() - 2 * 60 * 60 * 1000);
              guided.answers.missao_ini = mi.toISOString().slice(0, 16);
              guided.answers.missao_fim = mf.toISOString().slice(0, 16);
              renderGuidedStep();
            });
          }
        }, 0);
        return;
      }

      if (s === 4) {
        guidedBody.innerHTML = `
      <h2>5) Débito do recurso</h2>
      ${select("g_deb", "Tipo", [
          { value: "cchsa", label: "CCHSA" },
          { value: "cavn", label: "CAVN" },
          { value: "projeto", label: "Projeto" },
          { value: "outros", label: "Outros" },
        ], a.deb_tipo)}
      <div id="g_deb_det_wrap" style="display:${(a.deb_tipo === "projeto" || a.deb_tipo === "outros") ? "block" : "none"};">
        ${input("g_deb_det", "Detalhe (obrigatório para Projeto/Outros)", "text", a.deb_det, "Ex.: Nome/código do projeto")}
      </div>
      <div class="helper">Se escolher Projeto/Outros, informe o detalhe.</div>
    `;
        setTimeout(() => {
          const sel = document.getElementById("g_deb");
          if (sel) {
            sel.addEventListener("change", () => {
              guided.answers.deb_tipo = sel.value;
              if (sel.value !== "projeto" && sel.value !== "outros") guided.answers.deb_det = "";
              renderGuidedStep();
            });
          }
        }, 0);
        return;
      }

      if (s === 5) {
        const items = [
          { id: "g_t_vo", label: "Veículo oficial", value: "veiculo_oficial", checked: a.meios.includes("veiculo_oficial"), small: "Quando houver disponibilidade institucional." },
          { id: "g_t_et", label: "Empresa terrestre", value: "empresa_terrestre", checked: a.meios.includes("empresa_terrestre"), small: "Ônibus/van/serviço terrestre." },
          { id: "g_t_ea", label: "Empresa aérea", value: "empresa_aerea", checked: a.meios.includes("empresa_aerea"), small: "Quando houver emissão aérea." },
          { id: "g_t_vp", label: "Veículo próprio", value: "veiculo_proprio", checked: a.meios.includes("veiculo_proprio"), small: "Exige ciência do termo." },
        ];

        guidedBody.innerHTML = `
      <h2>6) Transporte</h2>
      ${multiCheckbox(items)}
      <div id="g_termo_wrap" style="display:${a.meios.includes("veiculo_proprio") ? "block" : "none"}; margin-top:10px;">
        ${checkbox("g_termo", "Ciente do termo de opção (obrigatório para veículo próprio)", a.veic_proprio_ciente)}
      </div>
      <div class="helper">Selecione ao menos um meio. Se marcar veículo próprio, marque ciência do termo.</div>
    `;

        setTimeout(() => {
          items.forEach(it => {
            const el = document.getElementById(it.id);
            if (el) {
              el.addEventListener("change", () => {
                if (el.checked) guided.answers.meios = Array.from(new Set([...guided.answers.meios, it.value]));
                else guided.answers.meios = guided.answers.meios.filter(x => x !== it.value);

                if (!guided.answers.meios.includes("veiculo_proprio")) {
                  guided.answers.veic_proprio_ciente = false;
                }
                renderGuidedStep();
              });
            }
          });

          const termo = document.getElementById("g_termo");
          if (termo) {
            termo.addEventListener("change", () => guided.answers.veic_proprio_ciente = termo.checked);
          }
        }, 0);
        return;
      }

      if (s === 6) {
        // resumo
        guidedBody.innerHTML = `
      <h2>7) Revisão rápida</h2>
      <pre style="white-space:pre-wrap;margin:0;color:rgba(255,255,255,0.85);font-size:12.5px;">
Tipo: ${a.tipo_solicitacao || "—"}
Data solicitação: ${a.data_solicitacao || "—"}

Ida: ${a.ida_origem || "—"} → ${a.ida_destino || "—"} | ${a.ida_dt || "—"}
Retorno: ${a.ret_origem || "—"} → ${a.ret_destino || "—"} | ${a.ret_dt || "—"}

Missão: ${a.missao_ini || "—"} até ${a.missao_fim || "—"}

Recurso: ${a.deb_tipo || "—"} ${a.deb_det ? "(" + a.deb_det + ")" : ""}
Transporte: ${(a.meios || []).join(", ") || "—"}
Veículo próprio - termo: ${a.meios.includes("veiculo_proprio") ? (a.veic_proprio_ciente ? "ciente" : "NÃO marcado") : "N/A"}
      </pre>

      <div class="helper">Ao aplicar, o wizard será preenchido e você seguirá para os campos que exigem texto (ex.: motivo).</div>
    `;
        return;
      }
    }

    /* Validação por passo do assistente guiado */
    function guidedValidateStep() {
      const a = guided.answers;
      const msgs = [];

      const req = (v, m) => { if (!v) msgs.push(m); };

      if (guided.step === 0) {
        req(a.tipo_solicitacao, "Selecione o tipo de solicitação.");
        req(a.data_solicitacao, "Informe a data da solicitação.");
      }
      if (guided.step === 1) {
        req(a.ida_origem, "Informe a origem da ida.");
        req(a.ida_destino, "Informe o destino da ida.");
        req(a.ida_dt, "Informe data e hora da ida.");
      }
      if (guided.step === 2) {
        req(a.ret_origem, "Informe a origem do retorno.");
        req(a.ret_destino, "Informe o destino do retorno.");
        req(a.ret_dt, "Informe data e hora do retorno.");
        if (a.ida_dt && a.ret_dt) {
          const ida = new Date(a.ida_dt);
          const ret = new Date(a.ret_dt);
          if (ret < ida) msgs.push("Retorno não pode ser anterior à ida.");
        }
      }
      if (guided.step === 3) {
        req(a.missao_ini, "Informe o início da missão.");
        req(a.missao_fim, "Informe o término da missão.");
        if (a.missao_ini && a.missao_fim) {
          const mi = new Date(a.missao_ini);
          const mf = new Date(a.missao_fim);
          if (mf < mi) msgs.push("Término da missão não pode ser anterior ao início.");
        }
        if (a.ida_dt && a.ret_dt && a.missao_ini && a.missao_fim) {
          const ida = new Date(a.ida_dt);
          const ret = new Date(a.ret_dt);
          const mi = new Date(a.missao_ini);
          const mf = new Date(a.missao_fim);
          if (mi < ida) msgs.push("Início da missão não pode ser anterior à ida.");
          if (mf > ret) msgs.push("Término da missão não pode ser posterior ao retorno.");
        }
      }
      if (guided.step === 4) {
        req(a.deb_tipo, "Selecione o tipo de débito do recurso.");
        if ((a.deb_tipo === "projeto" || a.deb_tipo === "outros") && (!a.deb_det || a.deb_det.trim().length < 2)) {
          msgs.push("Informe o detalhe do recurso (Projeto/Outros).");
        }
      }
      if (guided.step === 5) {
        if (!a.meios || a.meios.length === 0) msgs.push("Selecione ao menos um meio de transporte.");
        if (a.meios.includes("veiculo_proprio") && !a.veic_proprio_ciente) {
          msgs.push("Para veículo próprio, marque ciência do termo.");
        }
      }

      gShowErrors(msgs.length ? msgs : null);
      return msgs.length === 0;
    }

    /* Aplicar no wizard principal */
    function guidedApplyToWizard() {
      const a = guided.answers;
      const prefill = {
        tipo_solicitacao: a.tipo_solicitacao,
        data_solicitacao: a.data_solicitacao,
        trechos: {
          ida: { origem: a.ida_origem, destino: a.ida_destino, data_hora: a.ida_dt ? (a.ida_dt + ":00") : "" },
          retorno: { origem: a.ret_origem, destino: a.ret_destino, data_hora: a.ret_dt ? (a.ret_dt + ":00") : "" }
        },
        missao: {
          inicio_data_hora: a.missao_ini ? (a.missao_ini + ":00") : "",
          termino_data_hora: a.missao_fim ? (a.missao_fim + ":00") : ""
        },
        debito_recurso: {
          tipo: a.deb_tipo,
          detalhe: a.deb_det
        },
        transporte: {
          meios: a.meios,
          termo_veiculo_proprio_ciente: a.veic_proprio_ciente
        }
      };

      // Usa a função applyPrefill do wizard (já existente)
      applyPrefill(prefill);

      // Ajustar UI condicional do wizard principal:
      // - débito detalhe
      const debTipoEl = document.getElementById("deb_tipo");
      if (debTipoEl) {
        debTipoEl.value = a.deb_tipo;
        debTipoEl.dispatchEvent(new Event("change"));
      }
      // - veículo próprio termo
      const vp = document.getElementById("chkVeicProprio");
      if (vp) {
        vp.checked = a.meios.includes("veiculo_proprio");
        vp.dispatchEvent(new Event("change"));
      }
      const termo = document.getElementById("termoCiente");
      if (termo) {
        termo.checked = a.veic_proprio_ciente;
      }

      // Vai para o primeiro campo que tipicamente exige texto: Motivo (passo 3)
      // (ou você pode ir direto para o próximo passo incompleto)
      guidedModal.style.display = "none";
      gotoStep(3);
    }

    /* Eventos do modal */
    const btnOpenGuided = document.getElementById("btnAssistantGuided");
    const guidedClose = document.getElementById("guidedClose");
    const guidedBack = document.getElementById("guidedBack");
    const guidedNext = document.getElementById("guidedNext");

    btnOpenGuided.addEventListener("click", () => {
      gShowErrors(null);
      guidedModal.style.display = "block";
      gSetStep(0);
    });

    guidedClose.addEventListener("click", () => {
      guidedModal.style.display = "none";
    });

    guidedBack.addEventListener("click", () => {
      gSetStep(guided.step - 1);
    });

    guidedNext.addEventListener("click", () => {
      // Capturar valores do passo atual antes de validar e avançar
      const a = guided.answers;

      function read(id) {
        const el = document.getElementById(id);
        return el ? el.value : "";
      }

      if (guided.step === 0) {
        a.tipo_solicitacao = read("g_tipo");
        a.data_solicitacao = read("g_data_sol");
      }
      if (guided.step === 1) {
        a.ida_origem = read("g_ida_ori").trim();
        a.ida_destino = read("g_ida_des").trim();
        a.ida_dt = read("g_ida_dt");
      }
      if (guided.step === 2) {
        a.ret_origem = read("g_ret_ori").trim();
        a.ret_destino = read("g_ret_des").trim();
        a.ret_dt = read("g_ret_dt");
      }
      if (guided.step === 3) {
        a.missao_ini = read("g_mi");
        a.missao_fim = read("g_mf");
      }
      if (guided.step === 4) {
        a.deb_tipo = read("g_deb");
        if (a.deb_tipo === "projeto" || a.deb_tipo === "outros") {
          a.deb_det = read("g_deb_det").trim();
        } else {
          a.deb_det = "";
        }
      }
      // step 5 já é atualizado por listeners
      // step 6 é revisão

      if (!guidedValidateStep()) return;

      if (guided.step === guided.total - 1) {
        guidedApplyToWizard();
        return;
      }
      gSetStep(guided.step + 1);
    });
  </script>




</body>

</html>